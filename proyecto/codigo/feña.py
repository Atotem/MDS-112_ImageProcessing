# -*- coding: utf-8 -*-
"""FeÃ±a

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VStN_CBEHy4wx4zjTebF6tqHs_a67acj
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt
from skimage import measure
from time import time
import scipy.ndimage as ndi

bgr = cv2.imread('Caras01.jpg')

# Image Smoothing

average_blur = cv2.blur(bgr,(5,5))
median_blur = cv2.medianBlur(bgr,5)
gaussian_blur = cv2.GaussianBlur(bgr,(5,5),0)

plt.imshow(average_blur)
plt.show()
plt.imshow(median_blur)
plt.show()
plt.imshow(gaussian_blur)
plt.show()

bgr = gaussian_blur

#Contrast Fix

plt.imshow(bgr)
plt.show()

lab = cv2.cvtColor(bgr, cv2.COLOR_BGR2LAB)

lab_channels = cv2.split(lab)

clahe = cv2.createCLAHE(clipLimit = 2.0, tileGridSize = (5, 5))

lab_channels[0] = clahe.apply(lab_channels[0])

lab = cv2.merge(lab_channels)

bgr = cv2.cvtColor(lab, cv2.COLOR_LAB2BGR)

plt.imshow(bgr)
plt.show()

ycrcb = cv2.cvtColor(lab, cv2.COLOR_BGR2YCrCb)

canal = 2

test = ycrcb[470:600, 1000:1080,:]
plt.imshow(test[:,:,canal], cmap="gray")
plt.show()

hst = cv2.calcHist([test],[canal],None,[256],[0,256])
plt.plot(hst)
plt.xticks(np.arange(255, step=15))
plt.show()

test2 = ycrcb[540:610, 110:190,:]
plt.imshow(test2[:,:,canal], cmap="gray")
plt.show()

hst2 = cv2.calcHist([test2],[canal],None,[256],[0,256])
plt.xticks(np.arange(255, step=15))
plt.plot(hst2)
plt.show()

test3 = ycrcb[420:500, 525:580,:]
plt.imshow(test3[:,:,canal], cmap="gray")
plt.show()

hst31 = cv2.calcHist([test3],[0],None,[256],[0,256])
hst32 = cv2.calcHist([test3],[1],None,[256],[0,256])
hst33 = cv2.calcHist([test3],[canal],None,[256],[0,256])
plt.title('face0 \ YCrCb')
plt.xticks(np.arange(255, step=15))
plt.plot(hst31, c='red', label='Y')
plt.plot(hst32, c='green', label='Cr')
plt.plot(hst33, c='blue', label='Cb')
plt.legend()
plt.show()

test4 = ycrcb[190:280, 313:375,:]
plt.imshow(test4[:,:,canal], cmap="gray")
plt.show()

hst4 = cv2.calcHist([test4],[canal],None,[256],[0,256])
plt.xticks(np.arange(255, step=15))
plt.plot(hst4)
plt.show()

test5 = ycrcb[455:560, 1565:1650,:]
plt.imshow(test5[:,:,canal], cmap="gray")
plt.show()

hst5 = cv2.calcHist([test5],[canal],None,[256],[0,256])
plt.xticks(np.arange(255, step=15))
plt.plot(hst5)
plt.show()

test6 = ycrcb[400:480, 0:120,:]
plt.imshow(test6[:,:,canal], cmap="gray")
plt.show()

hst6 = cv2.calcHist([test6],[canal],None,[256],[0,256])
plt.xticks(np.arange(255, step=15))
plt.plot(hst6)
plt.show()

test7 = ycrcb[95:310, 520:625,:]
plt.imshow(test7[:,:,canal], cmap="gray")
plt.show()

hst7 = cv2.calcHist([test7],[canal],None,[256],[0,256])
plt.xticks(np.arange(255, step=15))
plt.plot(hst7)
plt.show()

print(hst.tolist().index(max(hst).astype('int')[0]))
print(hst2.tolist().index(max(hst2).astype('int')[0]))
# print(hst3.tolist().index(max(hst3).astype('int')[0]))
print(hst4.tolist().index(max(hst4).astype('int')[0]))
print(hst5.tolist().index(max(hst5).astype('int')[0]))
print(hst6.tolist().index(max(hst6).astype('int')[0]))
print(hst7.tolist().index(max(hst7).astype('int')[0]))

#Skin Color Segmentation

#ycrcb = cv2.cvtColor(lab, cv2.COLOR_BGR2YCrCb)
height, width, depth = ycrcb.shape
bitmap = np.zeros((height, width))

Y_MIN = 148
Y_MAX = 154
CR_MIN = 114
CR_MAX = 130
CB_MIN = 100
CB_MAX = 179

for i in range(0, height):
  for j in range(0, width):
    if ((ycrcb[i,j,0]>=Y_MIN and ycrcb[i,j,0]<=Y_MAX) and (ycrcb[i,j,1]>=CR_MIN and ycrcb[i,j,1]<=CR_MAX) and (ycrcb[i,j,2]>=CB_MIN and ycrcb[i,j,2]<=CB_MAX)):
      bitmap[i,j] = 255

plt.imshow(bitmap, cmap="gray")
plt.show()

import scipy.ndimage as ndi

def filtro_mediana(A):
  S = np.median(A.flatten())
  return S

# img_med = cv2.medianBlur(bitmap, 5)
img_med = ndi.generic_filter(bitmap, filtro_mediana, [11, 11])
print('listo')

plt.figure(figsize=(10, 10))
plt.imshow(bitmap, cmap='gray')
plt.show()

plt.figure(figsize=(10, 10))
plt.imshow(img_med, cmap='gray')
plt.show()

kernel_dilation = cv2.getStructuringElement(cv2.MORPH_CROSS, (9, 9))
dil = cv2.dilate(img_med, kernel_dilation)

kernel_erosion = cv2.getStructuringElement(cv2.MORPH_CROSS, (3,3))
ero = cv2.erode(dil, kernel_erosion)

plt.figure(figsize=(10, 10))
plt.imshow(ero, cmap="gray")
plt.show()

A = ero < 120
A = ero > 120
A = A * 1
AC = cv2.bitwise_not(A).astype('uint8')

plt.imshow(AC, cmap='gray')
plt.show()

#kernel
kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(5,5))

#creacion imagen
m,n = AC.shape
M = np.zeros([m,n], dtype=np.uint8)
BIN= np.zeros([m,n], dtype=np.uint8)

#inicializacion
ind = np.where(AC == 255)         #buscamos un valor donde img sea blanco
# BIN[ind[0], ind[1]]     = 255
M[ind[0][0], ind[1][0]] = 255     #inicializamos un valor en 255

for i in range(0,1000):
    M = cv2.bitwise_and(cv2.dilate(M, kernel), AC)

K = cv2.bitwise_not(M).astype('uint8')
# R = cv2.bitwise_and(K, BIN)

len(ind[0])

plt.figure(figsize=(10, 10))
plt.imshow(K, cmap='gray')
plt.show()

plt.figure(figsize=(10, 10))
plt.imshow(R, cmap='gray')
plt.show()

K[600:640, 1200:1240]

# componentes conectados
all_labels = measure.label(K)

# (x1, y1, x2, y2)

for region in measure.regionprops(label_image=all_labels):
  if ((region.bbox[2] - region.bbox[0]) > 200) or ((region.bbox[3] - region.bbox[1]) > 200):
    for i in range(len(region.coords)):
      K[region.coords[i][0], region.coords[i][1]] = 0

plt.figure(figsize=(10, 10))
plt.imshow(K, cmap='gray')
plt.show()

ero_n = np.uint8(ero)

h, w = ero_n.shape[:2]
mask = np.zeros((h + 2, w + 2), np.uint8)

img_fill = ero_n.copy()
cv2.floodFill(img_fill, mask, (1450, 400), 1) # (1450, 400)

plt.figure(figsize=(10, 10))
plt.imshow(img_fill, cmap='gray')
plt.show()

kernel_erosion = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3,3))
erosion = cv2.erode(bitmap, kernel_erosion)
plt.imshow(erosion, cmap="gray")
plt.show()

kernel_dilation = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (6,6))
dilation = cv2.dilate(erosion, kernel_dilation)
plt.imshow(dilation, cmap="gray")
plt.show()

def filtro_mediana(A):
  S = np.median(A.flatten())
  return S

def modelo(imagen):
  tiempos_algoritmos = []
  t = time()
  # # compare blur
  # average_blur = cv2.blur(bgr,(5,5))
  # median_blur = cv2.medianBlur(bgr,5)
  gaussian_blur = cv2.GaussianBlur(imagen,(5,5),0)

  bgr = gaussian_blur

  # contrast fix
  lab = cv2.cvtColor(bgr, cv2.COLOR_BGR2LAB)

  # extract channels from lab
  lab_channels = cv2.split(lab)

  # ecualization of channel 0
  clahe = cv2.createCLAHE(clipLimit = 2.0, tileGridSize = (5, 5))
  lab_channels[0] = clahe.apply(lab_channels[0])

  # merge channels
  lab = cv2.merge(lab_channels)

  # change space to BGR | YCrCb
  bgr = cv2.cvtColor(lab, cv2.COLOR_LAB2BGR)
  ycrcb = cv2.cvtColor(lab, cv2.COLOR_BGR2YCrCb)

  tiempos_algoritmos.append(['preprocesamiento', round(time() - t, 2)])
  t = time()

  # bitmap with same shape from image
  height, width, depth = ycrcb.shape
  bitmap = np.zeros((height, width))

  # choose between range (from the faces)
  Y_MIN = 148
  Y_MAX = 154
  CR_MIN = 114
  CR_MAX = 130
  CB_MIN = 100
  CB_MAX = 179

  # generate binary image with values between face's range
  for i in range(0, height):
    for j in range(0, width):
      if ((ycrcb[i,j,0]>=Y_MIN and ycrcb[i,j,0]<=Y_MAX) and (ycrcb[i,j,1]>=CR_MIN and ycrcb[i,j,1]<=CR_MAX) and (ycrcb[i,j,2]>=CB_MIN and ycrcb[i,j,2]<=CB_MAX)):
        bitmap[i,j] = 255

  tiempos_algoritmos.append(['segmentacion YCrCb', round(time() - t, 2)])
  t = time()

  # filtro de la mediana
  img_med = ndi.generic_filter(bitmap, filtro_mediana, [11, 11])

  tiempos_algoritmos.append(['filtro mediana', round(time() - t, 2)])
  t = time()

  # dilatacion
  kernel_dilation = cv2.getStructuringElement(cv2.MORPH_CROSS, (9, 9))
  dil = cv2.dilate(img_med, kernel_dilation)

  # erosion
  kernel_erosion = cv2.getStructuringElement(cv2.MORPH_CROSS, (3,3))
  ero = cv2.erode(dil, kernel_erosion)

  tiempos_algoritmos.append(['dilatacion y erosion', round(time() - t, 2)])
  t = time()

  # valores entre 0 y 1 y obtencion de la imagen inversa
  A = ero < 120
  A = ero > 120
  A = A * 1
  AC = cv2.bitwise_not(A).astype('uint8')

  # relleno
  kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(5,5))

  #creacion imagen
  m, n = AC.shape
  M = np.zeros([m, n], dtype=np.uint8) # matriz de ceros

  #inicializacion
  ind = np.where(AC == 255)         # buscamos un valor donde img sea blanco
  M[ind[0][0], ind[1][0]] = 255     # inicializamos un valor en 255

  for i in range(0,1000):
      M = cv2.bitwise_and(cv2.dilate(M, kernel), AC) # proceso de relleno

  # se vuelve a invertir la imagen
  K = cv2.bitwise_not(M).astype('uint8')

  tiempos_algoritmos.append(['relleno', round(time() - t, 2)])
  t = time()

  # eliminamos las componentes muy grandes (ej: brazos)
  # componentes conectados
  all_labels = measure.label(K)

  for region in measure.regionprops(label_image=all_labels):
    if ((region.bbox[2] - region.bbox[0]) > 200) or ((region.bbox[3] - region.bbox[1]) > 200): # si las dimensiones son mayores a 200 px de alto o ancho
      for i in range(len(region.coords)):
        K[region.coords[i][0], region.coords[i][1]] = 0 # se 'eliminan'

  tiempos_algoritmos.append(['eliminacion de componentes', round(time() - t, 2)])

  # # erosion
  # kernel_erosion = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3,3))
  # erosion = cv2.erode(bitmap, kernel_erosion)

  # # dilatation
  # kernel_dilation = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (6,6))
  # dilation = cv2.dilate(erosion, kernel_dilation)

  # return dilation
  return K, tiempos_algoritmos

# img = cv2.imread('Caras01.jpg')
# result = modelo(img)

imagenes = ['Caras01.jpg', 'Caras02.jpg', 'Caras03.jpg', 'Caras04.jpg', 'Caras05.jpg', 'Caras06.jpg', 'Caras07.jpg', ]

# run model for each image
# for i in imagenes:
#     img = cv2.imread(i)
#     plt.imshow(modelo(img), cmap="gray")
#     plt.title(i+' Segmentada')
#     # plt.savefig(i[0:7]+'_segmentada.jpg')
#     plt.show()

import cv2
import numpy as np
from matplotlib import pyplot as plt
from skimage import measure
from time import time
import scipy.ndimage as ndi

f1_scores = []
tiempos = []

for i in range(7):

    refer = cv2.imread('Refer0'+str(i+1)+'.bmp')
    refer = cv2.cvtColor(refer, cv2.COLOR_BGR2GRAY)

    # transformar a una imagen binaria
    img_bin_ideal = refer > 127 # modificar
    # img_ideal_segmentada = modelo(img) > 127 # modificar
    img = cv2.imread('Caras0'+str(i+1)+'.jpg')
    img_modelada, tiempo = modelo(img)
    tiempos.append(tiempo)
    img_ideal_segmentada = img_modelada

    # dejamos valores en ceros y unos
    img_bin_ideal = img_bin_ideal*1
    # img_ideal_segmentada = img_ideal_segmentada*1

    # calcular diferencias
    diferencias = img_bin_ideal -  img_ideal_segmentada

    # calcular estadisticas
    TP = np.sum(diferencias == 0)
    FP = np.sum(diferencias == -1)
    FN = np.sum(diferencias == 1)

    print('-----------------------------------')
    print('Imagen '+ str(i+1))
    print('Hay {} True Positive'.format(TP))
    print('Hay {} False Positive'.format(FP))
    print('Hay {} False Negative'.format(FN))

    # despliegue de imagenes
    fig, ax = plt.subplots(nrows=1, ncols=3, dpi=150)
    ax[0].imshow(img_bin_ideal, cmap='gray')
    ax[1].imshow(img_ideal_segmentada, cmap='gray')
    ax[2].imshow(diferencias, cmap='gray')

    ax[0].set_title('Imagen ideal')
    ax[1].set_title('Imagen Segmentada')
    ax[2].set_title('Diferencias')
    # plt.savefig('Diferencias_imagen'+str(i)+'.jpg')
    plt.show()

    TPR = TP / (TP + FN)
    P = TP / (FP + TP)
    F1_score = 2 * (TPR * P) / (TPR + P)

    f1_scores.append(F1_score)

    print('F1 score: {}'.format(round(F1_score, 5)))
    print('Tiempo de ejecucion: {} [s]'.format(round(np.array(tiempos[len(tiempos)-1])[:, 1].astype('float').sum(), 2)))

"""# Analisis de resultados"""

f1_scores
f1_scores_antiguos = [0.9756, 0.9775, 0.9806, 0.9840, 0.9863, 0.9829, 0.9784]

fig, ax = plt.subplots(figsize=(10, 7))
ax.set_title('F1 Scores', c='white')
ax.set_xlabel('fotos', c='white')
ax.set_ylabel('score', c='white')
ax.set_ylim(0.975, 0.987)
ax.tick_params(axis='x', colors="white")
ax.tick_params(axis='y', colors="white")
ax.plot(np.arange(7), f1_scores)
plt.show()

np.array(tiempos[0])[:, 1].astype('float')

# plt.plot(np.array(tiempos[0])[:, 1].astype('float'))
# plt.show()

fig, ax = plt.subplots(figsize=(10, 7))
ax.set_title('Tiempos de Ejecucion', c='white')
ax.set_ylabel('tiempo [s]', c='white')
ax.tick_params(axis='x', colors="white")
ax.tick_params(axis='y', colors="white")
ax.plot(np.array(tiempos[0])[:, 0], np.array(tiempos[0])[:, 1].astype('float'))
plt.show()

# tiempos
ts = []
for t in tiempos:
  ts.append(np.array(t)[:, 1].astype('float'))

ts = np.array(ts)
ts_mean = ts.mean(axis=0)

fig, ax = plt.subplots(figsize=(10, 7))
ax.set_title('Promedios Tiempos de Ejecucion', c='white')
ax.set_ylabel('tiempo [s]', c='white')
ax.tick_params(axis='x', colors="white")
ax.tick_params(axis='y', colors="white")
ax.plot(np.array(tiempos[0])[:, 0], ts_mean)
plt.show()

ts_mean