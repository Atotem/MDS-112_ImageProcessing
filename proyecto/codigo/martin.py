# -*- coding: utf-8 -*-
"""Martin

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ytSwFELDjO9cdGgalg-W7q7R8MEyBi8u
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

#Open a simple image
img=cv2.imread('content/Caras01.jpg')

#converting from gbr to hsv color space
img_HSV = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

plt.figure()
plt.imshow(img_HSV)
plt.show()

#skin color range for hsv color space 
HSV_mask = cv2.inRange(img_HSV, (0, 15, 0), (17,170,255)) 
HSV_mask = cv2.morphologyEx(HSV_mask, cv2.MORPH_OPEN, np.ones((3,3), np.uint8))

#converting from gbr to YCbCr color space
img_YCrCb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)

plt.figure()
plt.imshow(HSV_mask)
plt.show()

plt.figure()
plt.imshow(img_YCrCb)
plt.show()

#skin color range for hsv color space 
YCrCb_mask = cv2.inRange(img_YCrCb, (0, 135, 85), (255,180,135)) 
YCrCb_mask = cv2.morphologyEx(YCrCb_mask, cv2.MORPH_OPEN, np.ones((3,3), np.uint8))

#merge skin detection (YCbCr and hsv)
global_mask=cv2.bitwise_and(YCrCb_mask,HSV_mask)
global_mask=cv2.medianBlur(global_mask,3)
global_mask = cv2.morphologyEx(global_mask, cv2.MORPH_OPEN, np.ones((4,4), np.uint8))

HSV_result = cv2.bitwise_not(HSV_mask)
YCrCb_result = cv2.bitwise_not(YCrCb_mask)
global_result=cv2.bitwise_not(global_mask)

ret,thresh1 = cv2.threshold(global_result,127,255,cv2.THRESH_BINARY)

print(thresh1)

plt.figure()
plt.imshow(thresh1)
plt.show()
#cv2.imwrite("1_HSV.jpg",HSV_result)
#cv2.imwrite("2_YCbCr.jpg",YCrCb_result)
#cv2.imwrite("3_global_result.jpg",global_result)
cv2.waitKey(0)
cv2.destroyAllWindows()

kernel = np.ones((20,20),np.uint8)
dilation = cv2.dilate(thresh1,kernel,iterations = 1)

kernel = np.ones((13,13),np.uint8)
erosion = cv2.erode(dilation,kernel,iterations = 1)

ret, thresh = cv2.threshold(erosion, 240, 255, cv2.THRESH_BINARY)

erosion[thresh == 255] = 0
erosion[thresh == 0] = 1


plt.figure()
plt.imshow(erosion, cmap="gray")
plt.show()

# transformar a una imagen binaria
img_bin_ideal = img=cv2.imread('content/Refer01.bmp',0)
img_ideal_segmentada = erosion

# transformar a una imagen binaria
img_bin_ideal = img_bin_ideal > 127 # must be 0 or 255
#img_ideal_segmentada = img_ideal_segmentada > 127 # must be 0 or 255

# dejamos valores en ceros y unos
img_bin_ideal = img_bin_ideal*1
img_ideal_segmentada = img_ideal_segmentada*1

# calcular diferencias
diferencias =  img_ideal_segmentada - img_bin_ideal

# calcular estadisticas
TP = np.sum(diferencias == 0)
FP = np.sum(diferencias == -1)
FN = np.sum(diferencias == 1)

print('Hay {} True Positive'.format(TP))
print('Hay {} False Positive'.format(FP))
print('Hay {} False Negative'.format(FN))

# despliegue de imagenes
fig, ax = plt.subplots(nrows=1, ncols=3, dpi=150)
ax[0].imshow(img_bin_ideal, cmap='gray')
ax[1].imshow(img_ideal_segmentada, cmap='gray')
ax[2].imshow(diferencias, cmap='gray')

ax[0].set_title('Imagen ideal')
ax[1].set_title('Imagen Segmentada')
ax[2].set_title('Diferencias')
plt.show()

TPR = TP / (TP + FN)
P = TP / (FP + TP)
F1_score = 2 * (TPR * P) / (TPR + P)

print('F1 score: {}'.format(round(F1_score, 5)))

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Read image
im_in = cv2.imread("personas.jpg", cv2.IMREAD_GRAYSCALE);

# Threshold.
# Set values equal to or above 220 to 0.
# Set values below 220 to 255.
th, im_th = cv2.threshold(im_in, 220, 255, cv2.THRESH_BINARY_INV)

# Copy the thresholded image.
im_floodfill = im_th.copy()

# Mask used to flood filling.
# Notice the size needs to be 2 pixels than the image.
h, w = im_th.shape[:2]
mask = np.zeros((h+2, w+2), np.uint8)
# Floodfill from point (0, 0)

cv2.floodFill(im_floodfill, mask, (0,0), 255);

# Invert floodfilled image
im_floodfill_inv = cv2.bitwise_not(im_floodfill)

# Combine the two images to get the foreground.
im_out = im_th | im_floodfill_inv
# Display images.

plt.imshow(im_th)
plt.show()

plt.imshow(im_floodfill)
plt.show()

plt.imshow(im_floodfill_inv)
plt.show()

plt.imshow(im_out)
plt.show()

